#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

layout(push_constant)       uniform Parameters {
  // GLSL has uints.
  //   https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Scalars
  uint iResolution_x;
  uint iResolution_y;
  float time;
} parameters;

vec2 iResolution;
float iTime;

// SDF for a sphere
float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

// 2D box
float sdBox(vec2 p, vec2 size) {
    vec2 d = abs(p) - size;
    return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);
}

// 2D circle
float sdCircle(vec2 p, float r) {
    return length(p) - r;
}

// 2D for "G"
float sdG(vec2 p) {
    float outerCircle = sdCircle(p, 0.5);

    float innerCircle = sdCircle(p, 0.4);

    float ring = max(outerCircle, -innerCircle);

    vec2 gapPos = p - vec2(0.1, 0.0);
    float gapRect = sdBox(gapPos, vec2(0.5, 0.1));
    ring = max(ring, -gapRect);

    vec2 barPos = p - vec2(0.2, -0.15);
    float barRect = sdBox(barPos, vec2(0.25, 0.05));
    float gShape = min(ring, barRect);

    return gShape;
}

float sdG3D(vec3 p) {
    float g2d = sdG(p.xy);
    float thickness = 0.2;
    float dist = abs(p.z) - thickness;
    return max(g2d, dist);
}

float rayTrace(vec3 ro, vec3 rd) {
    float t = 0.0;
    const float maxDistance = 100.0;
    const int maxSteps = 100;
    const float epsilon = 0.001;

    for(int i = 0; i < maxSteps; i++) {
        vec3 pos = ro + rd * t;
        float dist = sdG3D(pos);
        if(dist < epsilon) {
            return t;
        }
        t += dist;
        if(t > maxDistance) break;
    }
    return -1.0;
}

vec3 getNormal(vec3 p) {
    float h = 0.0001;
    vec3 n;
    n.x = sdG3D(p + vec3(h, 0, 0)) - sdG3D(p - vec3(h, 0, 0));
    n.y = sdG3D(p + vec3(0, h, 0)) - sdG3D(p - vec3(0, h, 0));
    n.z = sdG3D(p + vec3(0, 0, h)) - sdG3D(p - vec3(0, 0, h));
    return normalize(n);
}

vec3 getLighting(vec3 p, vec3 rd) {
    vec3 lightPos = vec3(5.0, 5.0, 5.0);
    vec3 lightDir = normalize(lightPos - p);
    vec3 normal = getNormal(p);

    vec3 ambient = vec3(0.1);

    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = diff * vec3(0.6, 0.7, 0.9);

    vec3 viewDir = normalize(-rd);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    vec3 specular = spec * vec3(1.0);

    return ambient + diffuse + specular;
}

vec3 getBackgroundColor(vec2 uv) {
    vec3 topColor = vec3(0.0, 0.0, 0.2);    // Dark blue
    vec3 bottomColor = vec3(0.0, 0.2, 0.5); // Lighter blue
    return mix(bottomColor, topColor, uv.y);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    // Normalize pixel coordinates
    vec2 uv = fragCoord.xy / iResolution.xy;
    vec2 p = uv * 2.0 - 1.0;
    p.x *= iResolution.x / iResolution.y;

    // Camera
    vec3 ro = vec3(0.0, 0.0, 3.0);
    vec3 rd = normalize(vec3(p, -1.5));

    // Rotate
    float angle = iTime * 0.5;
    mat3 rotation = mat3(
        cos(angle), 0.0, sin(angle),
        0.0,        1.0, 0.0,
        -sin(angle), 0.0, cos(angle)
    );
    rd = rotation * rd;
    ro = rotation * ro;

    float t = rayTrace(ro, rd);

    vec3 color;
    if(t > 0.0) {
        vec3 pos = ro + rd * t;
        color = getLighting(pos, rd);
    } else {
        color = getBackgroundColor(uv);
    }

    fragColor = vec4(color, 1.0);
}

void main()
{
  iResolution = vec2(parameters.iResolution_x, parameters.iResolution_y);
  iTime = parameters.time;

  vec4 fragColor;
  vec2  fragCoord  = vec2(gl_GlobalInvocationID.xy);
  ivec2 iFragCoord = ivec2(gl_GlobalInvocationID.xy);
  mainImage(fragColor, fragCoord);

  if (iFragCoord.x < 1280 && iFragCoord.y < 720)
    imageStore(resultImage, iFragCoord, fragColor);
}
